{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let SolutionsGeneratorService = /*#__PURE__*/(() => {\n  class SolutionsGeneratorService {\n    constructor() {}\n    generateSolutions(allPuzzlePieces) {\n      //allPuzzlePieces = Array(4) \n      this.allPuzzlePieces = allPuzzlePieces;\n      this.allSolvedPuzzlePieces = new Array();\n      console.log('STARTED');\n      let simpleNumArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n      this.row1Perm(0, 0, simpleNumArray);\n      console.log('COMPLETED');\n      return this.allSolvedPuzzlePieces;\n    }\n    // Fits Row Functions:\n    //checks fit of new puzzlePiece in given index/location (0 --> 9)\n    //puzzlePiece param should be a cell of arrPuzzlePieces\n    fitsRowOne(indexToCheck, puzzlePiece) {\n      if (this.allPuzzlePieces[0][indexToCheck] === puzzlePiece.top) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    //checks fit of new puzzlePiece in given index/location (0 --> 9)\n    fitsRowTwo(indexToCheck, puzzlePiece) {\n      let rowOneLeftIndex, rowOneRightIndex;\n      if (indexToCheck === 0) {\n        rowOneLeftIndex = 9;\n        rowOneRightIndex = 0;\n      } else {\n        rowOneLeftIndex = indexToCheck - 1;\n        rowOneRightIndex = indexToCheck;\n      }\n      if (this.allPuzzlePieces[1][rowOneLeftIndex].right === puzzlePiece.left && this.allPuzzlePieces[1][rowOneRightIndex].left === puzzlePiece.right) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    //checks fit of new puzzlePiece in given index/location (0 --> 4)\n    fitsRowThree(indexToCheck, puzzlePiece) {\n      let rowTwoLeftIndex, rowTwoRightIndex;\n      if (indexToCheck === 0) {\n        rowTwoLeftIndex = 1;\n        rowTwoRightIndex = 2;\n      } else if (indexToCheck === 1) {\n        rowTwoLeftIndex = 3;\n        rowTwoRightIndex = 4;\n      } else if (indexToCheck === 2) {\n        rowTwoLeftIndex = 5;\n        rowTwoRightIndex = 6;\n      } else if (indexToCheck === 3) {\n        rowTwoLeftIndex = 7;\n        rowTwoRightIndex = 8;\n      } else {\n        rowTwoLeftIndex = 9;\n        rowTwoRightIndex = 0;\n      }\n      if (this.allPuzzlePieces[2][rowTwoLeftIndex].bottom === puzzlePiece.left && this.allPuzzlePieces[2][rowTwoRightIndex].bottom === puzzlePiece.right) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    //SWITCH Functions\n    //switches 2 puzzle pieces for any given row\n    switchRow(switchSpotIdx, toSwitchInIdx, rowNum) {\n      let holdFirstPiece = this.allPuzzlePieces[rowNum][switchSpotIdx];\n      this.allPuzzlePieces[rowNum][switchSpotIdx] = this.allPuzzlePieces[rowNum][toSwitchInIdx];\n      this.allPuzzlePieces[rowNum][toSwitchInIdx] = holdFirstPiece;\n    }\n    // Permutation Functions: \n    //takes test spot, test piece, and record of current array setup (to reset the bankAvlbl)\n    //generates whole soln subset - testing all first layer switchIns, even after a match\n    row1Perm(switchSpot, toSwitchIn, simpleNumArray) {\n      //console.log('Row1: ' + switchSpot + \" <-\" + toSwitchIn);\n      //default set to true - sets false if 1.doesn't fit | 2.no more perms\n      let hasAvlblBranches = true;\n      //reset bankAvlblPuzzlePieces[] to match simpleNumArray\n      for (let i = 0; i < 10; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.allPuzzlePieces[1][i].id !== simpleNumArray[i]) {\n          for (let j = i; j < 10; j++) {\n            if (this.allPuzzlePieces[1][j].id === simpleNumArray[i]) {\n              this.switchRow(i, j, 1);\n            }\n          }\n        }\n      }\n      //checks if piece actually fits\n      if (this.fitsRowOne(switchSpot, this.allPuzzlePieces[1][toSwitchIn])) {\n        //checks if switch needs to be made (or already in place)\n        if (switchSpot !== toSwitchIn) {\n          this.switchRow(switchSpot, toSwitchIn, 1);\n          let holdFirstPlace = simpleNumArray[switchSpot];\n          simpleNumArray[switchSpot] = simpleNumArray[toSwitchIn];\n          simpleNumArray[toSwitchIn] = holdFirstPlace;\n        }\n        //if switchSpot < 8, then it will continue branching\n        //if switchSpot === 8, then it will check last cell to see if it's perfect row fit\n        if (switchSpot === 8) {\n          hasAvlblBranches = false;\n          if (this.fitsRowOne(9, this.allPuzzlePieces[1][9])) {\n            let simpleNumArray2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n            return this.row2Perm(0, 0, simpleNumArray2);\n          }\n        }\n      } else {\n        //or breaks out of all future branches/perms\n        //because current piece does not fit\n        hasAvlblBranches = false;\n      }\n      //explore all lower branches\n      //begin permutation process on next available puzzle piece spot\n      if (hasAvlblBranches) {\n        let newSwitchSpot = switchSpot + 1;\n        for (let i = newSwitchSpot; i < 10; i++) {\n          this.row1Perm(newSwitchSpot, i, [...simpleNumArray]);\n        }\n      }\n      //Call row1Perm to try ALL pieces in the current switchSpot\n      //regardless of current match or not\n      if (switchSpot === 0 && toSwitchIn === 0) {\n        for (let i = switchSpot + 1; i < 10; i++) {\n          this.row1Perm(switchSpot, i, [...simpleNumArray]);\n        }\n      }\n    } //end of row1Perm()\n    //takes test spot, test piece, and record of current array setup (to reset the bankAvlbl)\n    row2Perm(switchSpot, toSwitchIn, simpleNumArray) {\n      //console.log('Row2: ' + switchSpot + \" <-\" + toSwitchIn);\n      //default set to true - sets false if 1.doesn't fit | 2.no more perms\n      let hasAvlblBranches = true;\n      //reset bankAvlblPuzzlePieces[] to match simpleNumArray\n      for (let i = 0; i < 10; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.allPuzzlePieces[2][i].id !== simpleNumArray[i]) {\n          for (let j = i; j < 10; j++) {\n            if (this.allPuzzlePieces[2][j].id === simpleNumArray[i]) {\n              this.switchRow(i, j, 2);\n            }\n          }\n        }\n      }\n      //Call row2Perm to try ALL pieces in the current switchSpot\n      //regardless of current match or not\n      if (switchSpot === 0 && toSwitchIn === 0) {\n        let newSwitchSpot = switchSpot;\n        for (let i = switchSpot + 1; i < 10; i++) {\n          this.row2Perm(switchSpot, i, [...simpleNumArray]);\n        }\n      }\n      //checks if piece actually fits\n      if (this.fitsRowTwo(switchSpot, this.allPuzzlePieces[2][toSwitchIn])) {\n        //checks if switch needs to be made (or already in place)\n        if (switchSpot !== toSwitchIn) {\n          this.switchRow(switchSpot, toSwitchIn, 2);\n          let holdFirstPlace = simpleNumArray[switchSpot];\n          simpleNumArray[switchSpot] = simpleNumArray[toSwitchIn];\n          simpleNumArray[toSwitchIn] = holdFirstPlace;\n        }\n        //if switchSpot < 8, then it will continue branching\n        //if switchSpot == 8, then it will check last cell to see if it's perfect row fit\n        if (switchSpot === 8) {\n          hasAvlblBranches = false;\n          if (this.fitsRowTwo(9, this.allPuzzlePieces[2][9])) {\n            let simpleNumArray3 = [0, 1, 2, 3, 4];\n            return this.row3Perm(0, 0, simpleNumArray3);\n          }\n        }\n      } else {\n        //or breaks out of all future branches/perms \n        //because current piece does not fit\n        hasAvlblBranches = false;\n      }\n      //explore all lower branches\n      //begin permutation process on next available puzzle piece spot\n      if (hasAvlblBranches) {\n        let newSwitchSpot = switchSpot + 1;\n        for (let i = newSwitchSpot; i < 10; i++) {\n          this.row2Perm(newSwitchSpot, i, [...simpleNumArray]);\n        }\n      }\n    } //end of row2Perm()\n    //takes test spot, test piece, and record of current array setup (to reset the bankAvlbl)\n    row3Perm(switchSpot, toSwitchIn, simpleNumArray) {\n      //console.log(switchSpot + \" <--\" + toSwitchIn);\n      //default set to true - sets false if 1.doesn't fit | 2.no more perms\n      let hasAvlblBranches = true;\n      //reset bankAvlblPuzzlePieces[] to match simpleNumArray\n      for (let i = 0; i < 5; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.allPuzzlePieces[3][i].id !== simpleNumArray[i]) {\n          for (let j = i; j < 5; j++) {\n            if (this.allPuzzlePieces[3][j].id === simpleNumArray[i]) {\n              this.switchRow(i, j, 3);\n            }\n          }\n        }\n      }\n      //Call row3Perm to try ALL pieces in the current switchSpot\n      //regardless of current match or not\n      if (switchSpot === 0 && toSwitchIn === 0) {\n        let newSwitchSpot = switchSpot;\n        for (let i = switchSpot + 1; i < 5; i++) {\n          this.row3Perm(switchSpot, i, [...simpleNumArray]);\n        }\n      }\n      //checks if piece actually fits\n      if (this.fitsRowThree(switchSpot, this.allPuzzlePieces[3][toSwitchIn])) {\n        //checks if switch needs to be made (or already in place)\n        if (switchSpot !== toSwitchIn) {\n          this.switchRow(switchSpot, toSwitchIn, 3);\n          let holdFirstPlace = simpleNumArray[switchSpot];\n          simpleNumArray[switchSpot] = simpleNumArray[toSwitchIn];\n          simpleNumArray[toSwitchIn] = holdFirstPlace;\n        }\n        //if switchSpot < 3, then it will continue branching\n        //if switchSpot == 3, then it will check last cell to see if it's perfect fit\n        if (switchSpot === 3) {\n          hasAvlblBranches = false;\n          if (this.fitsRowThree(4, this.allPuzzlePieces[3][4])) {\n            this.cementSolvedArray();\n            return true;\n          }\n        }\n      } else {\n        //or breaks out of all future branches/perms\n        //because current piece does not fit\n        hasAvlblBranches = false;\n      }\n      //explore all lower branches\n      //begin permutation process on next available puzzle piece spot\n      if (hasAvlblBranches) {\n        let newSwitchSpot = switchSpot + 1;\n        for (let i = newSwitchSpot; i < 5; i++) {\n          this.row3Perm(newSwitchSpot, i, [...simpleNumArray]);\n        }\n      }\n    } //end of row3Perm()\n    cementSolvedArray() {\n      //create a new array to store solution from working copy in bankAvlblPuzzlePieces\n      const solvedPuzzlePieces = new Array(3);\n      solvedPuzzlePieces[0] = new Array(10);\n      solvedPuzzlePieces[1] = new Array(10);\n      solvedPuzzlePieces[2] = new Array(5);\n      for (let i = 0; i < 10; i++) {\n        solvedPuzzlePieces[0][i] = this.allPuzzlePieces[1][i].id;\n      }\n      for (let i = 0; i < 10; i++) {\n        solvedPuzzlePieces[1][i] = this.allPuzzlePieces[2][i].id;\n      }\n      for (let i = 0; i < 5; i++) {\n        solvedPuzzlePieces[2][i] = this.allPuzzlePieces[3][i].id;\n      }\n      //currently unnecessary, but confirms each new solution is unique\n      const alreadyExists = () => {\n        outer_loop: for (let i = 0; i < this.allSolvedPuzzlePieces.length; i++) {\n          for (let j = 0; j < 10; j++) {\n            if (this.allSolvedPuzzlePieces[i][0][j] !== solvedPuzzlePieces[0][j]) continue outer_loop;\n            if (this.allSolvedPuzzlePieces[i][1][j] !== solvedPuzzlePieces[1][j]) continue outer_loop;\n            if (j < 5) {\n              if (this.allSolvedPuzzlePieces[i][2][j] !== solvedPuzzlePieces[2][j]) continue outer_loop;\n            }\n          }\n          return true;\n        }\n      };\n      //push immediately to allSolvedPuzzlePieces if first solution\n      //or push after solution is confirmed unique\n      if (this.allSolvedPuzzlePieces.length === 0) {\n        console.log('     perfect fit!');\n        this.allSolvedPuzzlePieces.push(solvedPuzzlePieces);\n      } else if (!alreadyExists()) {\n        //console.log('     perfect fit!');\n        this.allSolvedPuzzlePieces.push(solvedPuzzlePieces);\n      }\n    } //end of cementSolvedArray()\n  }\n\n  //end of class\n  SolutionsGeneratorService.ɵfac = function SolutionsGeneratorService_Factory(t) {\n    return new (t || SolutionsGeneratorService)();\n  };\n  SolutionsGeneratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SolutionsGeneratorService,\n    factory: SolutionsGeneratorService.ɵfac,\n    providedIn: 'root'\n  });\n  return SolutionsGeneratorService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}