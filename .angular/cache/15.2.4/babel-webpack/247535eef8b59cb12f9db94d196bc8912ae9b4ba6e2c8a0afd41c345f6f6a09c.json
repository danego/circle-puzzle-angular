{"ast":null,"code":"import { BehaviorSubject, Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./solutions-generator.service\";\nimport * as i2 from \"./pieces-catalog.service\";\nexport let SolutionsGrabberService = /*#__PURE__*/(() => {\n  class SolutionsGrabberService {\n    constructor(solutionsGeneratorService, piecesCatalogService) {\n      this.solutionsGeneratorService = solutionsGeneratorService;\n      this.piecesCatalogService = piecesCatalogService;\n      this.allPuzzlePieces = new Array(4);\n      this.currentPuzzlePiecesSequence = new Array(4);\n      this.remainingSolutions = new BehaviorSubject(null);\n      this.allPiecesUsed = false;\n      this.currentPattern = 'Planets';\n      this.allPiecesUsedSubject = new Subject();\n      this.currentSolutionNumber = new Subject();\n      this.currentPatternSubject = new Subject();\n      //get pieces for default pattern (planets)\n      this.allPuzzlePieces = this.piecesCatalogService.getPiecesForSelectedPattern();\n      //initialize currentPuzzlePiecesSequence to track loaded piece sequence (used to update in CircleComponent)\n      this.makeDeepCopy();\n      //initialize _currentSolutionById to track only IDs\n      this.setupPieceIds();\n      //TEMPORARY FIX ... MIGHT MOVE ELSEWHERE\n      this.startGeneratingSolutions('planets');\n      this.setupPieceIdsEmpty();\n      this.computeRemainingSolutions(this._currentSolutionById);\n    }\n    //ADD CURRENT LAYOUT && ALREADY EXISITNG CONDITIONAL\n    startGeneratingSolutions(newPattern) {\n      //only generates solutions if not already done (ie passed in non-matching pattern)\n      //Later will need similar logic for different patterns (coins, scarabs)\n      if (newPattern && newPattern !== this.currentPattern) {\n        this.allGeneratedSolutionsById = this.solutionsGeneratorService.generateSolutions(this.allPuzzlePieces.slice());\n        this.currentPattern = newPattern;\n      }\n      return this.allGeneratedSolutionsById.length;\n    }\n    makeDeepCopy() {\n      this.currentPuzzlePiecesSequence = new Array(4);\n      this.currentPuzzlePiecesSequence[0] = [...this.allPuzzlePieces[0]];\n      this.currentPuzzlePiecesSequence[1] = [...this.allPuzzlePieces[1]];\n      this.currentPuzzlePiecesSequence[2] = [...this.allPuzzlePieces[2]];\n      this.currentPuzzlePiecesSequence[3] = [...this.allPuzzlePieces[3]];\n    }\n    makeDeepCopyFromSolution(solutionNumber) {\n      this._currentSolutionById = new Array(3);\n      this._currentSolutionById[0] = [...this.allGeneratedSolutionsById[solutionNumber][0]];\n      this._currentSolutionById[1] = [...this.allGeneratedSolutionsById[solutionNumber][1]];\n      this._currentSolutionById[2] = [...this.allGeneratedSolutionsById[solutionNumber][2]];\n    }\n    setupPieceIds() {\n      //initializes ID tracker to default puzzle piece order\n      this._currentSolutionById = new Array(3);\n      this._currentSolutionById[0] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n      this._currentSolutionById[1] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n      this._currentSolutionById[2] = [0, 1, 2, 3, 4];\n    }\n    setupPieceIdsEmpty() {\n      this._currentSolutionById = new Array(3);\n      this._currentSolutionById[0] = new Array(10).fill('');\n      this._currentSolutionById[1] = new Array(10).fill('');\n      this._currentSolutionById[2] = new Array(10).fill('');\n    }\n    changeCurrentPattern(pattern) {\n      this.allPuzzlePieces = this.piecesCatalogService.getPiecesForSelectedPattern(pattern);\n      //initialize currentPuzzlePiecesSequence to track loaded piece sequence (used to update in CircleComponent)\n      this.makeDeepCopy();\n      //initialize _currentSolutionById to track only IDs\n      this.setupPieceIds();\n      this.startGeneratingSolutions(pattern);\n      this.setupPieceIdsEmpty();\n      this.computeRemainingSolutions(this._currentSolutionById);\n      //emit for header style changes\n      this.currentPatternSubject.next(pattern);\n    }\n    moveAllPieces(moveType, solutionNumber) {\n      if (moveType === 'toBank') {\n        this.setupPieceIdsEmpty();\n      } else if (moveType === 'toCircle') {\n        //toCircle is either default order of pieces OR a new solution\n        if (solutionNumber || solutionNumber === 0) {\n          this.switchPieceOrderToNewSolution(solutionNumber);\n        } else {\n          this.switchPieceOrderToDefault();\n        }\n      }\n      this.computeRemainingSolutions();\n    }\n    switchPieceOrderToNewSolution(solutionNumber) {\n      //update ID tracker \n      this.makeDeepCopyFromSolution(solutionNumber);\n      //separate bc solutions do not include fixed layer 0\n      //Layer One\n      for (let i = 0; i < 10; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.currentPuzzlePiecesSequence[1][i].id !== this.allGeneratedSolutionsById[solutionNumber][0][i]) {\n          for (let j = i; j < 10; j++) {\n            if (this.currentPuzzlePiecesSequence[1][j].id === this.allGeneratedSolutionsById[solutionNumber][0][i]) {\n              this.switchPuzzlePieces(i, j, 1);\n            }\n          }\n        }\n      }\n      //Layer Two\n      for (let i = 0; i < 10; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.currentPuzzlePiecesSequence[2][i].id !== this.allGeneratedSolutionsById[solutionNumber][1][i]) {\n          for (let j = i; j < 10; j++) {\n            if (this.currentPuzzlePiecesSequence[2][j].id === this.allGeneratedSolutionsById[solutionNumber][1][i]) {\n              this.switchPuzzlePieces(i, j, 2);\n            }\n          }\n        }\n      }\n      //Layer Three\n      for (let i = 0; i < 5; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.currentPuzzlePiecesSequence[3][i].id !== this.allGeneratedSolutionsById[solutionNumber][2][i]) {\n          for (let j = i; j < 5; j++) {\n            if (this.currentPuzzlePiecesSequence[3][j].id === this.allGeneratedSolutionsById[solutionNumber][2][i]) {\n              this.switchPuzzlePieces(i, j, 3);\n            }\n          }\n        }\n      }\n    }\n    switchPieceOrderToDefault() {\n      //update ID tracker \n      this.setupPieceIds();\n      //separate bc solutions do not include fixed layer 0\n      //Layer One\n      for (let i = 0; i < 10; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.currentPuzzlePiecesSequence[1][i].id !== i) {\n          for (let j = i; j < 10; j++) {\n            if (this.currentPuzzlePiecesSequence[1][j].id === i) {\n              this.switchPuzzlePieces(i, j, 1);\n            }\n          }\n        }\n      }\n      //Layer Two\n      for (let i = 0; i < 10; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.currentPuzzlePiecesSequence[2][i].id !== i) {\n          for (let j = i; j < 10; j++) {\n            if (this.currentPuzzlePiecesSequence[2][j].id === i) {\n              this.switchPuzzlePieces(i, j, 2);\n            }\n          }\n        }\n      }\n      //Layer Three\n      for (let i = 0; i < 5; i++) {\n        //if bankAvlbl piece is already in position, skip to next index\n        //if not equal, run through bankAvlbl[] to find match & switch\n        if (this.currentPuzzlePiecesSequence[3][i].id !== i) {\n          for (let j = i; j < 5; j++) {\n            if (this.currentPuzzlePiecesSequence[3][j].id === i) {\n              this.switchPuzzlePieces(i, j, 3);\n            }\n          }\n        }\n      }\n    }\n    switchPuzzlePieces(switchSpotIndex, toSwitchInIndex, layerNumber) {\n      let holdFirstPiece = Object.assign({}, this.currentPuzzlePiecesSequence[layerNumber][switchSpotIndex]);\n      this.currentPuzzlePiecesSequence[layerNumber][switchSpotIndex] = Object.assign({}, this.currentPuzzlePiecesSequence[layerNumber][toSwitchInIndex]);\n      this.currentPuzzlePiecesSequence[layerNumber][toSwitchInIndex] = holdFirstPiece;\n    }\n    //deeply copies ID arrays from current solution\n    get currentSolutionById() {\n      const deepCopiedCurrentSolution = new Array(3);\n      for (let layer = 0; layer < 3; layer++) {\n        deepCopiedCurrentSolution[layer] = [...this._currentSolutionById[layer]];\n      }\n      return deepCopiedCurrentSolution;\n    }\n    computeRemainingSolutions(currentIdSequence) {\n      //empty argument is used for moving all pieces: empty, default, or new solution\n      currentIdSequence = currentIdSequence || this._currentSolutionById;\n      /*\n       * compare inputted sequence w/ every soln of 63\n       * quick exit if any position in any layer is not a match\n       * SO ... must be empty (=== \"\") or must match\n       */\n      let remainingSolutions = 0;\n      //solutions\n      solnLoop: for (let soln = 0; soln < this.allGeneratedSolutionsById.length; soln++) {\n        //layers\n        for (let layer = 0; layer < 3; layer++) {\n          let currentIdSequenceLayer = currentIdSequence[layer];\n          //pieceIds\n          for (let piece = 0; piece < currentIdSequenceLayer.length; piece++) {\n            if (currentIdSequenceLayer[piece] !== \"\" && currentIdSequenceLayer[piece] !== this.allGeneratedSolutionsById[soln][layer][piece]) {\n              continue solnLoop;\n            }\n          }\n        }\n        //all layers and pieces are a go\n        remainingSolutions++;\n      }\n      //emit updated status only if already true\n      if (this.allPiecesUsed) {\n        this.allPiecesUsed = false;\n        this.allPiecesUsedSubject.next(false);\n      }\n      //potentially update display current solution and allPiecesUsed\n      if (remainingSolutions === 1) {\n        this.determineCurrentSolutionNumber(currentIdSequence);\n      }\n      this.remainingSolutions.next(remainingSolutions);\n    }\n    determineCurrentSolutionNumber(currentIdSequence) {\n      //runs through current ID sequence checking all pieces are used (no empty strings)\n      for (let i = 0; i < 3; i++) {\n        let currentIdSequenceLayer = currentIdSequence[i];\n        //pieceIds\n        for (let piece = 0; piece < currentIdSequenceLayer.length; piece++) {\n          if (currentIdSequenceLayer[piece] === '') {\n            //if some spots are empty, then no need to update allPiecesUsed or check for matching solution below\n            return;\n          }\n        }\n      }\n      this.allPiecesUsed = true;\n      this.allPiecesUsedSubject.next(true);\n      let currentSolutionNumber;\n      //goes through each soln in allSolutions to find matching one\n      solnLoop: for (let soln = 0; soln < this.allGeneratedSolutionsById.length; soln++) {\n        //layers\n        for (let layer = 0; layer < 3; layer++) {\n          let currentIdSequenceLayer = currentIdSequence[layer];\n          //pieceIds\n          for (let piece = 0; piece < currentIdSequenceLayer.length; piece++) {\n            if (currentIdSequenceLayer[piece] !== this.allGeneratedSolutionsById[soln][layer][piece]) {\n              continue solnLoop;\n            }\n          }\n        }\n        currentSolutionNumber = soln;\n        break solnLoop;\n      }\n      this.currentSolutionNumber.next(currentSolutionNumber);\n    }\n  }\n  SolutionsGrabberService.ɵfac = function SolutionsGrabberService_Factory(t) {\n    return new (t || SolutionsGrabberService)(i0.ɵɵinject(i1.SolutionsGeneratorService), i0.ɵɵinject(i2.PiecesCatalogService));\n  };\n  SolutionsGrabberService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SolutionsGrabberService,\n    factory: SolutionsGrabberService.ɵfac,\n    providedIn: 'root'\n  });\n  return SolutionsGrabberService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}