{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let PositionBottomStartDirective = /*#__PURE__*/(() => {\n  class PositionBottomStartDirective {\n    constructor() {}\n    ngOnChanges() {\n      const piece = +this.pieceNumber;\n      this.fontSizeNumber = +this.fontSize;\n      this.circleRadius = +this.circleHeight * this.fontSizeNumber / 2;\n      this.convertToAngleCssCartesian(this.convertToAngleDegrees(piece), piece);\n      this.generateRotateDegrees(piece);\n    }\n    convertToAngleDegrees(piece) {\n      //piece 0 starts at 54deg. Each next piece is 72deg away\n      const degrees = piece * 72 + 54;\n      //triangle degrees is the angle between hypotenuse and X-axis\n      //correspond piece number to quadrant to correctly calculate triangle degrees\n      let triangleDegrees;\n      if (piece === 0) {\n        triangleDegrees = degrees;\n      } else if (piece === 1) {\n        triangleDegrees = 180 - degrees;\n      } else if (piece === 2) {\n        triangleDegrees = degrees - 180;\n      } else {\n        triangleDegrees = 360 - degrees;\n      }\n      return triangleDegrees;\n    }\n    //takes the degree of triangle to X axis and the piece # to determine quadrant\n    convertToAngleCssCartesian(triangleDegrees, piece) {\n      //halve inputted dimensions for puzzle piece     \n      const accountForPieceX = +this.pieceWidth * this.fontSizeNumber / 2;\n      const accountForPieceY = +this.pieceHeight * this.fontSizeNumber / 2;\n      //we must push from opposite direction and thus must add in radius\n      const xLegPlusCircle = this.circleRadius * this.getCosFromDegrees(triangleDegrees);\n      const yLegPlusCircle = this.circleRadius * this.getSinFromDegrees(triangleDegrees);\n      const pushXAxis = Math.floor(xLegPlusCircle + this.circleRadius - accountForPieceX);\n      const pushYAxis = Math.floor(yLegPlusCircle + this.circleRadius - accountForPieceY);\n      //correspond piece number to quadrant to correctly apply positioning\n      if (piece === 0) {\n        this.right = pushXAxis.toString() + 'px';\n        this.bottom = pushYAxis.toString() + 'px';\n      } else if (piece === 1) {\n        this.left = pushXAxis.toString() + 'px';\n        this.bottom = pushYAxis.toString() + 'px';\n      } else if (piece === 2) {\n        this.left = pushXAxis.toString() + 'px';\n        this.top = pushYAxis.toString() + 'px';\n      } else {\n        this.right = pushXAxis.toString() + 'px';\n        this.top = pushYAxis.toString() + 'px';\n      }\n    }\n    //Math.cos works in radians by default\n    getCosFromDegrees(degrees) {\n      return Math.cos(degrees * Math.PI / 180);\n    }\n    getSinFromDegrees(degrees) {\n      return Math.sin(degrees * Math.PI / 180);\n    }\n    generateRotateDegrees(piece) {\n      //backwards switch statement w/ no breaks\n      //piece (0) with largest degree value runs through all cases\n      let rotationDegrees = 0;\n      switch (piece) {\n        case 0:\n          rotationDegrees += 72;\n        case 4:\n          rotationDegrees += 72;\n        case 3:\n          rotationDegrees += 72;\n        case 2:\n          rotationDegrees += 72;\n        case 1:\n          rotationDegrees += 36;\n      }\n      this.rotate = `rotate(${rotationDegrees}deg)`;\n    }\n  }\n  PositionBottomStartDirective.ɵfac = function PositionBottomStartDirective_Factory(t) {\n    return new (t || PositionBottomStartDirective)();\n  };\n  PositionBottomStartDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: PositionBottomStartDirective,\n    selectors: [[\"\", \"positionBottomStart\", \"\"]],\n    hostVars: 10,\n    hostBindings: function PositionBottomStartDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"top\", ctx.top)(\"bottom\", ctx.bottom)(\"left\", ctx.left)(\"right\", ctx.right)(\"transform\", ctx.rotate);\n      }\n    },\n    inputs: {\n      pieceNumber: [\"positionBottomStart\", \"pieceNumber\"],\n      circleHeight: \"circleHeight\",\n      pieceWidth: \"pieceWidth\",\n      pieceHeight: \"pieceHeight\",\n      fontSize: [\"currentFontSize\", \"fontSize\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return PositionBottomStartDirective;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}