{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let PositionLeftStartDirective = /*#__PURE__*/(() => {\n  class PositionLeftStartDirective {\n    constructor() {}\n    ngOnChanges() {\n      const piece = +this.pieceNumber;\n      this.fontSizeNumber = +this.fontSize;\n      this.circleRadius = +this.circleHeight * this.fontSizeNumber / 2;\n      this.convertToAngleCssCartesian(this.convertToAngleDegrees(piece), piece);\n      this.generateRotateDegrees(piece);\n    }\n    convertToAngleDegrees(piece) {\n      //piece 0 starts at 18deg. Each next piece is 36deg away\n      const degrees = piece * 36;\n      //triangle degrees is the angle between hypotenuse and X-axis\n      //correspond piece number to quadrant to correctly calculate triangle degrees\n      let triangleDegrees;\n      if (piece <= 2) {\n        triangleDegrees = degrees;\n      } else if (piece > 2 && piece <= 4) {\n        triangleDegrees = 180 - degrees;\n      } else if (piece > 4 && piece <= 7) {\n        triangleDegrees = degrees - 180;\n      } else {\n        //pieces 8, 9\n        triangleDegrees = 360 - degrees;\n      }\n      return triangleDegrees;\n    }\n    //takes the degree of triangle to X axis and the piece # to determine quadrant\n    convertToAngleCssCartesian(triangleDegrees, piece) {\n      //halve inputted dimensions for puzzle piece     \n      const accountForPieceX = +this.pieceWidth * this.fontSizeNumber / 2;\n      const accountForPieceY = +this.pieceHeight * this.fontSizeNumber / 2;\n      //we must push from opposite direction and thus must add in radius\n      const xLegPlusCircle = this.circleRadius * this.getCosFromDegrees(triangleDegrees);\n      const yLegPlusCircle = this.circleRadius * this.getSinFromDegrees(triangleDegrees);\n      const pushXAxis = Math.floor(xLegPlusCircle + this.circleRadius - accountForPieceX);\n      const pushYAxis = Math.floor(yLegPlusCircle + this.circleRadius - accountForPieceY);\n      //correspond piece number to quadrant to correctly apply positioning\n      if (piece <= 2) {\n        this.right = pushXAxis.toString() + 'px';\n        this.bottom = pushYAxis.toString() + 'px';\n      } else if (piece > 2 && piece <= 4) {\n        this.left = pushXAxis.toString() + 'px';\n        this.bottom = pushYAxis.toString() + 'px';\n      } else if (piece > 4 && piece <= 7) {\n        this.left = pushXAxis.toString() + 'px';\n        this.top = pushYAxis.toString() + 'px';\n      } else {\n        //pieces 8, 9\n        this.right = pushXAxis.toString() + 'px';\n        this.top = pushYAxis.toString() + 'px';\n      }\n    }\n    //Math.cos works in radians by default\n    getCosFromDegrees(degrees) {\n      return Math.cos(degrees * Math.PI / 180);\n    }\n    getSinFromDegrees(degrees) {\n      return Math.sin(degrees * Math.PI / 180);\n    }\n    generateRotateDegrees(piece) {\n      //backwards switch statement w/ no breaks\n      //piece (2) with largest degree value runs through all cases\n      let rotationDegrees = 0;\n      switch (piece) {\n        case 2:\n          rotationDegrees += 36;\n        case 1:\n          rotationDegrees += 36;\n        case 0:\n          rotationDegrees += 36;\n        case 9:\n          rotationDegrees += 36;\n        case 8:\n          rotationDegrees += 36;\n        case 7:\n          rotationDegrees += 36;\n        case 6:\n          rotationDegrees += 36;\n        case 5:\n          rotationDegrees += 36;\n        case 4:\n          rotationDegrees += 36;\n        case 3:\n          rotationDegrees += 18;\n      }\n      this.rotate = `rotate(${rotationDegrees}deg)`;\n    }\n  }\n  PositionLeftStartDirective.ɵfac = function PositionLeftStartDirective_Factory(t) {\n    return new (t || PositionLeftStartDirective)();\n  };\n  PositionLeftStartDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: PositionLeftStartDirective,\n    selectors: [[\"\", \"positionLeftStart\", \"\"]],\n    hostVars: 10,\n    hostBindings: function PositionLeftStartDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"top\", ctx.top)(\"bottom\", ctx.bottom)(\"left\", ctx.left)(\"right\", ctx.right)(\"transform\", ctx.rotate);\n      }\n    },\n    inputs: {\n      pieceNumber: [\"positionLeftStart\", \"pieceNumber\"],\n      circleHeight: \"circleHeight\",\n      pieceWidth: \"pieceWidth\",\n      pieceHeight: \"pieceHeight\",\n      fontSize: [\"currentFontSize\", \"fontSize\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return PositionLeftStartDirective;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}